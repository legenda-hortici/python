"""
    Оператор yield используется в функциях для создания генераторов.
    В отличие от return, который возвращает значение и завершает функцию,
    yield приостанавливает выполнение функции, сохраняя её состояние,
    и возвращает значение. При следующем вызове функция продолжает выполнение
    с места остановки. Это позволяет ленивое (on-demand) выполнение.
"""

"""
    1 - простой генератор
    2 - работа с yield
    3 - генераторы вместо списков
    4 - генераторные выражения
    5 - отправка значений в генератор (send)
    6 - генераторы с throw и close
    7 - примеры использования yield
    8 - генераторы и цикл for
"""

### 1 - простой генератор
"""
    Функция, содержащая yield, становится генератором.
    Она возвращает объект-генератор, который можно итерировать.
"""

# Пример: простой генератор
def simple_generator():
    yield 1
    yield 2
    yield 3

gen = simple_generator()
for value in gen:
    print(value) # 1, 2, 3

### 2 - работа с yield
"""
    При вызове генератора выполнение не начинается.
    Выполнение начинается при вызове next() или итерации.
    После каждого yield выполнение приостанавливается.
"""
def countdown(n):
    while n > 0:
        yield n
        n -= 1

gen = countdown(3)
print(next(gen)) # 3
print(next(gen)) # 2
print(next(gen)) # 1
# print(next(gen)) # вызовет StopIteration

### 3 - генераторы вместо списков
"""
    Генераторы экономят память, так как не создают все значения сразу.
    Это особенно полезно при работе с большими объёмами данных.
"""
# Пример: генератор квадратов
def squares_gen(n):
    for i in range(n):
        yield i ** 2

# Не создаёт весь список сразу
gen = squares_gen(5)
for square in gen:
    print(square) # 0, 1, 4, 9, 16

### 4 - генераторные выражения
"""
    Генераторы можно создавать с помощью выражений в круглых скобках.
    Они работают так же, как списковые включения, но возвращают генератор.
"""

# Пример: генераторное выражение
gen_expr = (x ** 2 for x in range(5))
for val in gen_expr:
    print(val) # 0, 1, 4, 9, 16

### 5 - отправка значений в генератор (send)
"""
    С помощью метода send() можно передавать значения в генератор.
    Это позволяет генератору быть корутиной.
"""
def echo_generator():
    while True:
        received = yield
        print(f"Получено: {received}")

gen = echo_generator()
next(gen) # запуск генератора
gen.send("Привет") # Получено: Привет
gen.send("Как дела?") # Получено: Как дела?

### 6 - генераторы с throw и close
"""
    - throw() — выбрасывает исключение в генераторе.
    - close() — закрывает генератор.
"""

def gen_with_exception():
    try:
        yield 1
        yield 2
    except ValueError:
        print("Обработка исключения")

gen = gen_with_exception()
print(next(gen)) # 1
gen.throw(ValueError) # Обработка исключения

### 7 - примеры использования yield
"""
    Генераторы полезны для:
    - Обработки больших файлов
    - Потоковой обработки данных
    - Постепенного выполнения задач
    - Экономии памяти
"""
def process(line: str):
    pass

def read_large_file(file_path):
    with open(file_path) as file:
        for line in file:
            yield line.strip()

for line in read_large_file("big_file.txt"):
    process(line)

### 8 - генераторы и цикл for
"""
    Генераторы совместимы с циклом for, так как являются итерируемыми.
"""
def fibonacci(n):
    a, b = 0, 1
    count = 0
    while count < n:
        yield a
        a, b = b, a + b
        count += 1

for num in fibonacci(10):
    print(num, end=" ") # 0 1 1 2 3 5 8 13 21 34

"""
    Основные особенности yield:
    1. Позволяет создавать генераторы.
    2. Приостанавливает выполнение функции и возвращает значение.
    3. Сохраняет состояние между вызовами.
    4. Позволяет ленивое вычисление.
    5. Экономит память по сравнению с созданиями списков.
    6. Поддерживает передачу значений через send().
    7. Используется в корутинах и потоковой обработке.
    8. Совместим с `for`, `next()`, `throw()`, `close()`.
"""

