"""
    По сути можно представить переменную, как коробку, в которую помещают что-либо,
    но правильнее сказать, что переменная это определенная область в памяти, которая
    хранит значение и имеет свой адрес. Каждая переменная обязана иметь свой тип данных.
"""

"""
    Перечисление типов данных в Python:
    1. int
    2. float
    3, bool
    4. str
    5. list
    6. tuple
    7. set
    8. dict
"""

### 1 - целочисленный тип данных
"""
    оператор "=" представляет присвоение переменной значения какого-либо типа.
    эту операцию называют инициализацией
"""
a_int = 100000000000000000000000000  # переменная "a_int" имеет тип int, который представляет целое число 1
val_int: int = 1  # более правильный вариант инициализации переменной с точным указанием типа
val_int = "abc"  # Expected type 'int', got 'str' instead | получаем ошибку несоответствия типов
b = c = 1  # вариант множественного присвоения значения нескольким переменным

### 2 - вещественный тип данных
a_float = 1.7  # переменная "a_float" имеет тип float, который представляет число с плавающей точкой, в данном случае 1.7
val_float: float = 1.7  # более правильный вариант инициализации переменной с точным указанием типа
"""
    переменной типа float можно присвоить значение типа int, потому что float может представить любое 
    целое число в пределах своей точности (до ~15–17 знаков). если переменной типа int присвоить float, то
    может произойти ошибка, если не выполнить явное преобразование (int(float_value)), особенно если 
    float содержит дробную часть.
"""
a_int = int(a_float)  # явное преобразование
a_float = a_int  # неявное преобразование типов

### 3 - логический тип bool
"""
    логический тип bool может иметь только 2 варианта значений: True или False (1 или 0 соответственно). 
    по умолчанию имеет значение False
"""
a_bool = False | True
val_bool: bool = True | False  # более правильный вариант инициализации переменной с точным указанием типа

### 4 - строковый тип данных
"""
    строка представляет собой неизменяемую (immutable) последовательность символов unicode.
    строки между собой можно конкатенировать, создавая новые строки, поскольку оригинальные строки не изменяются.
    при инициализации их можно объявлять через '' или "", разницы нет.
"""
s = "abc"
val_str: str = "abc"
s1 = "Hello"
s2 = "World"
s3_1 = s1 + " " + s2  # "Hello World" | конкатенация строк
s3_2 = f"{s1} {s2}"  # f-строка позволяет более удобно создавать новые строки
print(val_str[1])  # b | так как строки это последовательность символов, то можно получать символы через индексы

### 5 - тип данных список
"""
    список — это упорядоченная изменяемая (mutable) последовательность, 
    которая может содержать значения разных типов.
"""
arr = []  # самый простой вариант объявления списка
val_list: list = []  # аннотация типа — указывает, что переменная будет списком
arr = [1, 2, 3]  # при создании списка его можно заполнить значениями на месте
arr_val = list(range(3))  # [0, 1, 2] | ещё один вариант инициализации списка

"""
    - списки в Python — это динамические массивы, которые хранят ссылки(!) на объекты, а не сами объекты(!).
    - список состоит из:
      1. Метаданных (размер, вместимость, тип и т.д.)
      2. Массива указателей (ссылок) на объекты, содержащиеся в списке.
    - каждый элемент списка — это адрес (ссылка) на объект в памяти.
    - это позволяет спискам хранить объекты разных типов (int, str, dict и т.д.).
    - из-за этого изменение элемента списка не меняет сам массив, а лишь заменяет одну ссылку на другую.
    - также из-за этого копирование списка по умолчанию — поверхностное (shallow copy).
"""

arr[2] = 10  # [1, 2, 10] | к элементам списка можно обращаться по индексам и присваивать значения
# При этом в ячейке с индексом 2 теперь хранится ссылка на объект 10

slice = arr[:]  # [1, 2, 10] | создаёт новый список с копией ссылок (shallow copy)
# slice — это новый объект, но его элементы — те же объекты, что и в arr

slice_1 = arr[1:]  # [2, 10] | получаем слайс, начиная с 1 по индексу и до конца
slice_2 = arr[:1]  # [1] | получаем слайс до 1 по индексу (правая граница не включается)
slice_3 = arr[0:2]  # [1, 2] | получаем слайс с 0 по 2 (не включая 2)

arr += arr  # [1, 2, 10, 1, 2, 10] | расширение списка: добавляются новые ссылки на те же объекты
# Эквивалентно arr = arr + arr, но выполняется эффективнее (изменяет исходный список)

### 6 - тип данных кортеж
"""
    кортеж (tuple) — это упорядоченная, неизменяемая (immutable) коллекция,
    которая может содержать элементы разных типов. в отличие от списков, кортежи 
    нельзя изменить после создания. это делает их хэшируемыми (если все элементы 
    тоже хэшируемые), и позволяет использовать как ключи в словарях или элементы множеств.
"""
coll = (1, 2, "b")
# Создание кортежа: неизменяемой упорядоченной коллекции
# Скобки () не обязательны, но улучшают читаемость

"""
    1. Неизменяемость (immutable):
       - После создания кортежа нельзя изменить, добавить или удалить элементы.
       - Это означает, что кортежи безопасны от изменений и могут использоваться как "константы".
    2. Хранение в памяти:
       - Кортежи хранятся последовательно в памяти (как и списки), но размер фиксирован.
       - Кортежи занимают меньше памяти, чем списки, т.к. не требуют резерва под возможное расширение.
    3. Хэшируемость:
       - Если все элементы кортежа хэшируемы, то и сам кортеж — хэшируем.
       - Это позволяет использовать кортеж как ключ в словаре или элемент множества.
    4. Использование:
       - Для хранения фиксированных данных (например, координаты, дата, настройки).
       - Возвращаемые значения функций (например, divmod(10, 3) возвращает кортеж (3, 1)).
    5. Синтаксис создания:
       - (1, 2, 3) — с круглыми скобками
       - 1, 2, 3 — без скобок (всё равно кортеж)
       - (1,) — обязательная запятая, если один элемент (иначе это int)
       - () — пустой кортеж
"""

### 7 - тип данных множество
"""
    Множество (set) — это неупорядоченная коллекция уникальных элементов.
    Множества изменяемы (mutable), то есть можно добавлять, удалять и изменять элементы.
    Однако, элементы множества должны быть хэшируемыми (например, числа, строки, кортежи).
    Множества не могут содержать дубликаты — при добавлении уже существующего элемента он игнорируется.
    Множества не поддерживают индексацию, так как являются неупорядоченными.
"""
empty_set = set() # Создание пустого множества
numbers = {1, 2, 3, 4, 5} # Создание множества с элементами
mixed_set = {1, "hello", (1, 2), 3.14}

numbers.add(6) # {1, 2, 3, 4, 5, 6} | Добавление элемента
numbers.remove(6) # {1, 2, 3, 4, 5} | Удаление элемента (если элемента нет, будет ошибка)
numbers.discard(10) # {1, 2, 3, 4, 5} | Удаление элемента (если элемента нет, ошибки не будет)

set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1.union(set2) # {1, 2, 3, 4, 5} | объединение множеств

"""
    1. Неупорядоченность:
       - Элементы не имеют фиксированной позиции.
       - Порядок элементов может меняться при каждом выводе.
    2. Уникальность:
       - Все элементы множества уникальны.
       - Повторяющиеся элементы автоматически удаляются.
    3. Хэшируемые элементы:
       - Только хэшируемые объекты могут быть элементами множества.
       - Нельзя хранить списки, словари или другие множества внутри множества.
    4. Эффективность:
       - Операции добавления, удаления и поиска элементов выполняются за O(1) в среднем случае.
       - Это делает множества идеальными для проверки принадлежности и удаления дубликатов.
    5. Использование:
       - Удаление дубликатов из коллекций
       - Математические операции над множествами (объединение, пересечение и т.д.)
       - Быстрая проверка наличия элемента
    6. Синтаксис создания:
       - {} — создание множества с элементами (но {} создает словарь, а не пустое множество)
       - set() — создание пустого множества или преобразование итерируемого объекта в множество
"""

### 8 - тип данных словарь
"""
    Словарь (dict) — это коллекция пар "ключ-значение", где каждый ключ связан с определённым значением.
    Словари изменяемы (mutable), то есть можно добавлять, изменять и удалять пары "ключ-значение".
    Ключи должны быть уникальными и хэшируемыми (числа, строки, кортежи), а значения могут быть любыми объектами.
    Словари не упорядочены до версии Python 3.7 (в 3.7+ сохраняется порядок вставки).
"""
empty_dict = {} # Создание пустого словаря
person = {"name": "Alice", "age": 30} # Создание словаря с парами "ключ-значение"
student = dict(name="Bob", age=25, grade="A") # Создание словаря через dict()

name = person["name"] # "Alice" | Доступ к значению по ключу
# или с использованием get(), чтобы избежать ошибки, если ключа нет
grade = student.get("grade", "Unknown") # "A" или "Unknown", если ключа нет

# Добавление или изменение пары "ключ-значение"
person["job"] = "Engineer" # добавление новой пары
person["age"] = 31 # изменение существующего значения

# Удаление пары по ключу
del person["city"] # удаление пары с ключом "city"
removed_value = person.pop("job", "Not found") # удаление с возвратом значения

# Получение всех ключей, значений и пар
keys = person.keys() # dict_keys(['name', 'age'])
values = person.values() # dict_values(['Alice', 31])
items = person.items() # dict_items([('name', 'Alice'), ('age', 31)])

# Объединение словарей (Python 3.9+)
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}
merged = dict1 | dict2 # {"a": 1, "b": 2, "c": 3, "d": 4}

"""
    1. Пары "ключ-значение":
       - Каждый ключ связан с одним значением.
       - Ключи уникальны, значения могут повторяться.
    2. Хэшируемые ключи:
       - Только хэшируемые объекты могут быть ключами.
       - Нельзя использовать списки, словари или множества в качестве ключей.
    3. Эффективность:
       - Операции получения, добавления и удаления выполняются за O(1) в среднем случае.
       - Это делает словари идеальными для хранения и быстрого поиска данных.
    4. Удобство использования:
       - Интуитивно понятная структура данных.
       - Подходит для представления структурированной информации (например, JSON).
    5. Использование:
       - Хранение конфигураций, настроек, данных пользователей.
       - Реализация кэшей, таблиц соответствий, графов и т.д.
    6. Синтаксис создания:
       - {} — создание пустого словаря или словаря с парами
       - dict() — создание через конструктор
       - Генераторы словарей: {k: v for k, v in iterable}
"""
