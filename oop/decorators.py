class Vector:

    MIN_VALUE = 0
    MAX_VALUE = 100

    @classmethod
    # Декоратор @classmethod: метод ниже будет связан с КЛАССОМ, а не с ЭКЗЕМПЛЯРОМ
    def validate(cls, value):
        # cls — это ссылка на сам класс (Vector), передаётся автоматически
        return cls.MIN_VALUE <= value <= cls.MAX_VALUE
        # Возвращает результат проверки: находится ли value в диапазоне [MIN_VALUE, MAX_VALUE]

    def __init__(self, x, y):
        # Конструктор экземпляра: вызывается при создании объекта Vector(1, 2)
        self.x = self.y = 0
        # Инициализируем x и y значением 0 по умолчанию

        if self.validate(x) and self.validate(y):
        # Вызываем метод validate через экземпляр, но он всё равно получает cls (Vector)
            self.x = x
            self.y = y

    def get_fields(self):
        # Обычный метод экземпляра: возвращает координаты текущего объекта
        return self.x, self.y
        # Возвращает кортеж (x, y) текущего экземпляра

    @staticmethod
    # Декоратор @staticmethod: метод ниже не получает ни self, ни cls
    def sum(a, b):
        # Статический метод: работает как обычная функция, но находится внутри класса
        return a + b
        # Возвращает сумму двух чисел, никак не используя класс или экземпляр

v = Vector(1, 2)
# Создаём экземпляр класса Vector; вызывается __new__ -> __init__; x=1, y=2

print(v.sum(10, 20))
# Вызываем статический метод через экземпляр: sum(10, 20) -> 30
# На самом деле, Python находит метод в классе и вызывает его как Vector.sum(10, 20)

print(v.validate(10))
# Вызываем метод класса через экземпляр: validate(10)
# Python передаёт Vector как cls, и метод проверяет, находится ли 10 в диапазоне

"""
Резюме: чаще всего можно использовать простые методы без декораторов, однако если задача
требует работы с атрибутами или использовании вспомогательной функции внутри класса, то
использование декораторов будет правильнее и логичнее.
"""
